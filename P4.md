# Overloading vs Overriding in Java
###### By Bradley Pirie | Syracuse University | 10MAY2021

In languages like Java, programmers are able to make use of different object oriented programming (OOP) features like encapsulation, polymorphism, inheritance, etc. These concepts, combined with objects, classes, and methods, help programs represent real-life scenarios and offer a unique way to solve problems. Now this is just a breif overview of OOP, if you'd like to learn more about these ideas you can find a more indepth explanation ***[here](https://www.geeksforgeeks.org/object-oriented-programming-oops-concept-in-java/)***. For the purpose of this article we will assume that you already know what OOP is as well as some of the core concepts that go along with it. Here we will take a deeper look into method overloading and method overriding in Java.

## What is method overloading?

Method overloading occurs when a class has multiple methods with the same name but each method has a different signature. Signitures can differ by argument type or by the number of arguments being passed. When deciding which method corresponds to any given call, Java will choose the method who's signature matches what is being called.

```java
// For example the following class has multiple print methods
// that all have different signatures. The print method is being
// overloaded

public class Printer {
  public static void print() {                            // First print method takes no arguments
    System.out.println("Printing ...");
    }
  public static void print(int x) {                       // Second print method takes just an int
    System.out.printf("Printing %d messeges ...\n", x);
  }
  public static int print(int x, int y) {                 // Third print method takes 2 ints and
    int result = (x >= y ? x : y);                        // selects the larger of the two
    System.out.printf("Printing %d messeges ...\n", result);
    return result;
  }
  public static void print(String messege) {              // Fourth print method takes a string
    System.out.println("Printing the following messege: " + messege);
  }
  
  public static void main(String[] args) {
    print();                  // This matches the print method with no arguments
    print(5);                 // This matches the print method with 1 int arg
    print(8, 11);             // This matches the print method with 2 int args
    print("Hello world");     // This matches the print method with 1 String arg
  }
}
```

Running the main method above we can expect the following output

```
Printing ...
Printing 5 messeges ...
Printing 11 messeges ...
Printing the following messege: Hello world
```

Notice that each method has the same name, Java distinguishes which method should be used by matching the signatures. In the example above, the print method can be called with no args, 1 int arg, 2 int args, or 1 String arg. This is beneficial because you do not need to create and remember different method names for tasks that are all very similar. As we can see each print method is just a minor variation of the others. One of the most common and useful places to implement method overloading in Java is in an objects constructor. A constructor is a method that initializes an object and is often times overloaded to allow the programmer to pass values to initialize various class variables.

```java
public class Person {                 // This class represents a person object
  String name;                        // and has variables for the persons name
  int age;                            // and age.
  
  Person() {                          // Constructor that takes no args and sets
    this.name = null;                 // the variables to defualt values null & -1
    this.age = -1;
  }
  Person(String name) {               // Constructor that takes 1 String arg and
    this.name = name;                 // sets the name variable to the input string
    this.age = -1;
  }
  Person(int age) {                   // Constructor that takes 1 int arg and sets
    this.name = null;                 // the age variable to the input int
    this.age = age;
  }
  Person(String name, int age) {      // Constructor that takes 2 args, 1 String
    this.name = name;                 // and 1 int then sets the name variable to
    this.age = age;                   // input string and the age variable to input int
  }
  
  public static void main(String[] args) {
    Person p1 = new Person();                 // The Person constructor method above has been overloaded
    Person p2 = new Person("Bradley");        // which allows us to create different 'people' p1 - p4 that
    Person p3 = new Person(18);               // each have different initial name and age values but are all
    Person p4 = new Person("Bradley", 18);    // still Person objects
  }
}
```

Overloading constructors in Java is useful because programmers may only know a piece of the information contained in an object when the object is being created. Having multiple constructors accounts for the various cases where the programmer doesnt know all the information by letting them create the object with the information that they do have. We can see in the example above that by overloading the Person constructor we are able to create Person objects with different initializations. Overloading extends beyond just constructors though, it can be applied to static methods, public methods, even the main method, etc. The are many different situations where overloading comes in handy and we will look at how we can use overloading to solve a problem at the end of this post, but for now we will introduce method overriding in Java.

## What is method overriding?

Method overriding occurs when a child class contains the same method as its parent class. To fully understand this you will need to have basic knowledge of the OOP concept 'inheritance' in Java, you can find more information on this ***[here](https://www.geeksforgeeks.org/inheritance-in-java/)***. The need for method overriding inside a child class really depends on the relationship between that child and its parent class. Sometimes the parent class method doesnt make sense for a child object, but other times the child object will need to use one of the parent methods. In the latter case, the child class has two options. It can either use the exact same method contained in the parent class or it can override the method so that it completes a different task. Lets look at an example below.

```java
// In this example we have a parent class Animal and a child class
// Dog that extends Animal. Now the animal class has two methods, an
// eat method and an identify method. The dog class uses the same eat
// method as the animal class but dogs identify differently than the 
// general animal so the dog class overrides the identify method.

public class Animal {
  protected int age;                        // Animals age
  
  public void eat() {
    System.out.println("Yumm Yumm");        // Eats food
  }
  public void identify() {
    System.out.println("I am an animal");   // Identifies as an animal
  }
}
```
```java
public class Dog extends Animal {
  protected String type;
  
  public void identify() {
    System.out.println("I am a dog");
  }
}
```

Running the main method above we can expect the following output

```
Printing ...
Printing 5 messeges ...
Printing 11 messeges ...
Printing the following messege: Hello world
```

Notice that each method has the same name, Java distinguishes which method should be used by matching the signatures. In the example above, the print method can be called with no args, 1 int arg, 2 int args, or 1 String arg. This is beneficial because you do not need to create and remember different method names for tasks that are all very similar. As we can see each print method is just a minor variation of the others. One of the most common and useful places to implement method overloading in Java is in an objects constructor. A constructor is a method that initializes an object and is often times overloaded to allow the programmer to pass values to initialize various class variables.

```java
public class Person {                 // This class represents a person object
  String name;                        // and has variables for the persons name
  int age;                            // and age.
  
  Person() {                          // Constructor that takes no args and sets
    this.name = null;                 // the variables to defualt values null & -1
    this.age = -1;
  }
  Person(String name) {               // Constructor that takes 1 String arg and
    this.name = name;                 // sets the name variable to the input string
    this.age = -1;
  }
  Person(int age) {                   // Constructor that takes 1 int arg and sets
    this.name = null;                 // the age variable to the input int
    this.age = age;
  }
  Person(String name, int age) {      // Constructor that takes 2 args, 1 String
    this.name = name;                 // and 1 int then sets the name variable to
    this.age = age;                   // input string and the age variable to input int
  }
  
  public static void main(String[] args) {
    Person p1 = new Person();                 // The Person constructor method above has been overloaded
    Person p2 = new Person("Bradley");        // which allows us to create different 'people' p1 - p4 that
    Person p3 = new Person(18);               // each have different initial name and age values but are all
    Person p4 = new Person("Bradley", 18);    // still Person objects
  }
}
```

Overloading constructors in Java is useful because programmers may only know a piece of the information contained in an object when the object is being created. Having multiple constructors accounts for the various cases where the programmer doesnt know all the information by letting them create the object with the information that they do have. We can see in the example above that by overloading the Person constructor we are able to create Person objects with different initializations. Overloading extends beyond just constructors though, it can be applied to static methods, public methods, even the main method, etc. The are many different situations where overloading comes in handy and we will look at how we can use overloading to solve a problem at then end of this post. Next we will introduce method overriding in Java.
