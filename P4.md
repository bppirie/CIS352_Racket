# Overloading vs Overriding in Java
###### By Bradley Pirie | Syracuse University | 10MAY2021

In languages like Java, programmers are able to make use of different object oriented programming (OOP) features like encapsulation, polymorphism, inheritance, etc. These concepts, combined with objects, classes, and methods, help programs represent real-life scenarios and offer a unique way to solve problems. Now this is just a breif overview of OOP, if you'd like to learn more about these ideas you can find a more indepth explanation ***[here](https://www.geeksforgeeks.org/object-oriented-programming-oops-concept-in-java/)***. For the purpose of this article we will assume that you already know what OOP is as well as some of the core concepts that go along with it. Here we will take a deeper look into method overloading and method overriding in Java.

## What is method overloading?

Method overloading occurs when a class has multiple methods with the same name but each method has a different signature. Signitures can differ by argument type or by the number of arguments being passed. When deciding which method corresponds to any given call, Java will choose the method who's signature matches what is being called.

```java
// For example the following class has multiple print methods
// that all have different signatures. The print method is being
// overloaded

public class Printer {
  public static void print() {                            // First print method takes no arguments
    System.out.println("Printing ...");
    }
  public static void print(int x) {                       // Second print method takes just an int
    System.out.printf("Printing %d messeges ...\n", x);
  }
  public static int print(int x, int y) {                 // Third print method takes 2 ints and
    int result = (x >= y ? x : y);                        // selects the larger of the two
    System.out.printf("Printing %d messeges ...\n", result);
    return result;
  }
  public static void print(String messege) {              // Fourth print method takes a string
    System.out.println("Printing the following messege: " + messege);
  }
  
  public static void main(String[] args) {
    print();                  // This matches the print method with no arguments
    print(5);                 // This matches the print method with 1 int arg
    print(8, 11);             // This matches the print method with 2 int args
    print("Hello world");     // This matches the print method with 1 String arg
  }
}
```

Running the main method above we can expect the following output

```
Printing ...
Printing 5 messeges ...
Printing 11 messeges ...
Printing the following messege: Hello world
```

Notice that each method has the same name, Java distinguishes which method should be used by matching the signatures. In the example above, the print method can be called with no args, 1 int arg, 2 int args, or 1 String arg. This is beneficial because you do not need to create and remember different method names for tasks that are all very similar. As we can see each print method is just a minor variation of the others. One of the most common and useful places to implement method overloading in Java is in an objects constructor. A constructor is a method that initializes an object and is often times overloaded to allow the programmer to pass values to initialize various class variables.

```java
public class Person {                 // This class represents a person object
  String name;                        // and has variables for the persons name
  int age;                            // and age.
  
  Person() {                          // Constructor that takes no args and sets
    this.name = null;                 // the variables to defualt values null & -1
    this.age = -1;
  }
  Person(String name) {               // Constructor that takes 1 String arg and
    this.name = name;                 // sets the name variable to the input string
    this.age = -1;
  }
  Person(int age) {                   // Constructor that takes 1 int arg and sets
    this.name = null;                 // the age variable to the input int
    this.age = age;
  }
  Person(String name, int age) {      // Constructor that takes 2 args, 1 String
    this.name = name;                 // and 1 int then sets the name variable to
    this.age = age;                   // input string and the age variable to input int
  }
  
  public static void main(String[] args) {
    Person p1 = new Person();                 // The Person constructor method above has been overloaded
    Person p2 = new Person("Bradley");        // which allows us to create different 'people' p1 - p4 that
    Person p3 = new Person(18);               // each have different initial name and age values but are all
    Person p4 = new Person("Bradley", 18);    // still Person objects
  }
}
```

Overloading constructors in Java is useful because programmers may only know a piece of the information that will be contained in an object when the object is being created. Having multiple constructors accounts for the various cases where the programmer doesnt know all the information by letting them create the object with the information that they do have. We can see in the example above that by overloading the Person constructor we are able to create Person objects with different initializations. Overloading extends beyond just constructors though, it can be applied to static methods, public methods, even the main method, etc. The are many different situations where overloading comes in handy and we will look at how we can use overloading to solve a problem at the end of this post, but for now we will introduce method overriding in Java.

## What is method overriding?

Method overriding occurs when a child class contains the same method as its parent class. To fully understand this you will need to have basic knowledge of the OOP concept 'inheritance' in Java, you can find more information on this ***[here](https://www.geeksforgeeks.org/inheritance-in-java/)***. The need for method overriding inside a child class really depends on the relationship between that child and its parent class. Sometimes the parent class method doesnt make sense for a child object, but other times the child object will need to use one of the parent methods. In the latter case, the child class has two options. It can either use the exact same method contained in the parent class or it can override the method so that it completes a different task. Lets look at an example below.

```java
// In this example we have a parent class Animal and a child class
// Dog that extends Animal. Now the animal class has two methods, an
// eat() method and an identify() method. The dog class uses the same eat
// method as the animal class but dogs identify differently than the 
// general animal so the dog class overrides the identify() method.

public class Animal {
  protected int age;                        // Animals age
  
  public void eat() {
    System.out.println("Yumm Yumm");        // Eats food
  }
  public void identify() {
    System.out.println("I am an animal");   // Identifies as an animal
  }
}
```
```java
public class Dog extends Animal {
  protected String type;                    // Type of dog
  
  public void identify() {                  // Overrides identify() method for dog objects
    System.out.println("I am a dog");       // Identifies as a dog
  }
  
  public static void main(String[] args) {
    Animal a1 = new Animal();               // Create animal object
    Dog d1 = new Dog();                     // Create dog object
    
    a1.eat();                               // Uses eat() method in Animal class
    d1.eat();                               // Also uses eat() method in its parent Animal class
    a1.identify();                          // Uses identify() method in Animal class
    d1.identify();                          // Uses overriding method in Dog class
  }
}
```

Running the main method above we can expect the following output

```
Yumm Yumm
Yumm Yumm
I am an animal
I am a dog
```

Looking at this output we can see that the Animal object a1 and the Dog object d1 both used the same eat() method that is found within the Animal class. However, a1 and d1 used different identify() methods, they used the identify method that corresponds with their object class. Now there are multiple ways for a parent class to prevent method overriding in its child classes like using the 'final' keyword or making the method a static method. Using our example above here are three replacements for the eat method that will ensure Dog objects call the eat() method in the Animal class.

```java
// First we have the 'final' keyword
final public void eat() {
// Next we have the static method
public static void eat() {
// Finally we have the private access modifier
private void eat() {
```

This is a nice feature but what should we do if the child method just wants to add on to what the parent class method is already doing? Well there is another keyword 'super' that we can use to call the parent method from inside the overriding method in the child class. Lets do this with our Animal and Dog example by making the identify() method in the Dog class call the identify() method in the Animal class.

```java
public class Dog extends Animal {           // Our Dog class from before
  protected String type;
  
  public void identify() {
    super.identify();                       // Calling the identify() method in the Animal class
    System.out.println("and I am a dog");   // Adding/'extending' to include that the object is both animal and dog
  }
  
  public static void main(String[] args) {
    Dog d1 = new Dog();
    d1.identify();                         // Run the identify() method for dog objects
  }
}
```

Now when we run the identify() method on a dog object as shown in the main method above, we can expect this new output

```
I am an animal
and I am a dog
```

This new output lets us see that we can still run the original identify() method in the Animal class even though there is an overriding identify() method in the Dog class. Seeing this we can think about how overriding can play a very important role in a family of objects. Imagine we have an array of Animal pointers but each pointer points to a specific child object like a Dog object. This can be done with this line of code `Animal a1 = new Dog();`. Now lets say we want to have each animal in the array eat some food. Well if we have implemented overriding in our child classes then we should be able to just iterate through the array and call the eat() method on every object without having to check what the object actually is. This works because any object that doesnt need to eat in a special way will just use the eat() method in the Animal class but lets say we have a Turkey object and it makes the "Gobble Gobble" sound when it eats. Then all we have to do is override the eat() method in the Turkey class, so if there is a Turkey object in our array, we know that calling eat() will call the eat() method in the Turkey class instead of the Animal class. Ultimately saving the
